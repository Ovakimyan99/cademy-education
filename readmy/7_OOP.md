### 3 Кита ООП
Темы:
- Наследование
- Инкапсуляция
- Полиморфизм

---
#### Наследование
Наследование - это возможность унаследовать, получить возможности родителя.

#### Инкапсуляция
Инкапсуляция с позиции си подобных языков - это возможность скрыть один тип данных
под другими.

О чем речь?
Например:

```
class Person {
    constructor(name, lastname) {
        this.name = name;
        this.lastname = lastname;
    }
}

const person = new Person('Тигран', 'Овакимян');
```
Это и есть инкапсуляция. За одной сущностью `person` скрываем все остальные типы
данных. Все свойства, методы скрыты за `person`.

Инкапсуляция - это все те скрытые свойства и механики в классе от пользователя.

Мы о них ничего не знаем, методах и свойствах. Они просто скрыты внутри класса.
А теперь вспомним понятие интерфейса. В интерфейсе у нас есть возможность показать
все то, из чего состоит класс. Но все то, что не отображено в интерфейсе и ябвляется
инкапсулируемой частью.

А если бы мы тот же пример выше написали так:
```
let name = '';
let lastName = '';

function sayHello(name, lastname) {
    console.log('...')
}
```
То данные разрознены у нас не скрыты.

#### Полиморфизм
Полиморфизм нам говорит о том, что мы можем работать одинаково с разными по уровню
сложности объектами. Определение напоминает нам структурный паттерн `Composite / Компоновщик`.

Вся суть в том, что мы абстрагируемся от конкретных данных, но имеем возможность
обработать их одинаково. Например,

```
class OwnNumber {
    constructor(n) {
        this.n = n;
    }
    
    plus(instance) {
        retrurn this.n + instance.n;
    }
}

const n1 = new OwnNumber(1);
const n2 = new OwnNumber(2);

n1.plus(n2);
```

Окей, а теперь давайте сделаем то же самое, но со строками. Что мне мешает сделать так?
```
const str1 = new OwnNumber('str1');
const str2 = new OwnNumber('str2');

str1.plus(str2); // str1str2
```

Вот и полиморфизм.
