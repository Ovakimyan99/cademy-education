### Команды командной строки
##### LS
Отображает действующие файлы и папки на уровне директории, в которой
вызвана команда. Рассмотрим модификаторы:   
* **-a** - дополнительно показывает скрытые папки
* **-la** - показывает с правами доступа и в формате таблицы

##### CD
Позволяет перемещаться по дереву папок. Принимает 3 базовые команды:
* **./** - точка слэш - действует относительно папки, в которой вызвана команда
* **../** - две точки слэш - позволяет подняться на один уровень наверх
* **./dir | dir** - переходит в указанную папку

##### MKDIR
Создает папку. Пример команды:
* **mkdir dir_name** - создает папку с названием dir_name

##### RM
Удаляет файлы по умолчанию. Возможно и удаление папок, при этом надо использовать дополнительные флаги.
Пример команды:
* **rm file_name** - удаляет файл с названием dir_name
* **rm -r** - рекурсивно удаляет все файлы и каталоги и спрашивает об удалении каждого файла с папкой
* **rm -f** - делает то же самое, что и *-r*, но не спрашивает
* __-i mydir/*__ - удаляет все файлы в этой директории


### node_modules
Когда мы производим загрузку каких-либо пакетов, эти зависимости
устанавливаются в node_modules. Также устанавливаются зависимые для
выбранного пакета файлы. Также возможно такое, что в разных пакетах
используется одна и та же зависимость, но с разными версиями. Оба
будут скачены. Такое тоже возможно.

После одного инцидента, когда с npm удалили один очень известный пакет,
ввели новое правило в свою политику соглашения:
выкладываемые пакеты навсегда будут оставаться в npm. Удалить можно только через суд.


### Использование команды node
В консоли можно использовать "node + названиеФайла". В таком случае он отработает
и выведет в консоли результат выполнения кода. Работает node с ES5, поэтому если есть
желание использовать новые версии языка, то надо использовать babel. Его также надо настроить
и установить доп пакеты для того, чтобы node обрабатывал и трансформировал код в ES5.

У запуска кода через консоль есть преимущество перед браузером:
1. не надо формировать html файл
2. Не надо запускать браузер
3. Можно быстро перезапускать код, не дожидаясь перезапуска страницы браузера
4. Можно работать с пакетными зависимостями
5. Код отрабатывает быстрее (*)
6. Можно запускать тестирование кода

* Нам не приходиться дожидаться рендеринга страницы, стилей, парсинга html, css, js.
Мы пропускаем все эти этапы и сразу запускаем код.

Поскольку мы работаем с node, то надо знать и про его ограничения. У ноды нет
BOM, DOM, поэтому код с использованием этих объектов не будет работать.

Для работы с браузером есть webpack!


### require & module.export
Поговорим немного про импорты и экспорты ES5.
Мы можем импортировать файлы с использованием require:  
*const file = require('filename.js');*  

Есть одна очень важная особенность у пути к файлу. Если его не указывать, то файл будет
искаться в node_modules. Если мы хотим найти свой собственный файл, то надо прописывать путь, например
'./filename.js'

Когда мы импортируем с использованием require, то указывать расширения файлов необязательно по причине
того, что node достаточно вумный и понимает что ему искать. Сначала он ищет js файлы, потом, если не нашел,
json. Также он может смотреть в папку и искать index файл. Логика более сложная и длинная, но это знать
необязательно.

Также мы можем экспортировать файлы. В этом нам поможет следующий синтаксис:
module.export = 'то что хотим экспортировать'.


### babel
В проекте, как уже упоминалось ранее, babel нужен для компиляции кода в ES5. В проекте пакеты babel
нужно сохранять в dev-dependencies, так это нужно только на этапе разработки и сборки проекта. Находиться
ему в бандле смысла нет. То есть его задача преобразовать код. Делаться это будет единожды. Для использования
babel-node надо установить пакеты в сам проект, в добавок их надо установить глобально на пк, чтобы появилась
возможность использовать команды в консоли: babel-node

После
npm i -g @babel/core @babel/node @babel/plugin-transform-runtime @babel/preset-env @babel/runtime  
я имею возможность вызывать babel-node в консоли.

### Webpack
Это тот же сборщик, что и Gulp и прочие, но он более быстрый и гибкий в настройке плагинов. Также
в Gulp настройка идет в виде задач, а в webpack в виде потоков.

webpack-dev-server - это уже за нас настроенный сервер.
Также я использую HtmlWebpackPlugin, чтобы передать html файл в вебпак со своей версткой. Никакие скрипты
внутри подключать не надо, вебпак самостоятельно это все делает.

Режим - mode - можно указать как в webpack, так в package.json в scripts

Если это происходит в webpack, то можно подключить cross-env с целью кроссплатформенного использования
env. В скриптах в env указывать режим разработки, а в webpack.config получать это значение.

### Nodemon
Что это за демон такой и как его можно использовать?
Фактически его используют так:
в командной строке пишем nodemon file.js

После этого он будет следить за этим файлом и выводить в консоли результат кода. Консольную строку
перезапускать смысла не имеет, он это будет делать самостоятельно. И получается так, что nodemon отправляет
файл node и тот его обрабатывает. Именно поэтому, если мы используем что-то из es6+, что не поддерживает
node, к нам на помощь придет babel. Nodemon можно сказать, чтобы он использовал для компиляции babel:  
**nodemon --exec babel-node file.js** - здесь мы передаем управление babel-node

Как вы можете заметить, команда длинная, запоминать и переписывать из раза в раз для запуска - это
проблематично, поэтому ее можно вынести в scripts в package.json и использовать npm run

webpack в браузере, nodemon в консоли.

### Mocha & chai
Для тестирования мы будем использовать Mocha, а для запуска chai.
Чтобы использовать mocha с возможностями es6+, надо прописать следующую команду:
**mocha --require @babel/register**

Надо также вызвать метод should прежде чем напишем код тестирования.
