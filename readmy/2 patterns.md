Прежде чем поговорим о паттернах, хочу указать темы, которые поспособствуют изучению
паттернов и большему пониманию механик и движков в JS.

##### Темы изучения:
- Ссылочная природа объектов
- Объект
  - поля
  - методы
    - контекст
    - заимствование контекста
- Магия __proro\__
  - конвертация в prototype
- Фабрика объектов
  - Присвоение методов
  - Доступ методов через __proto\__
    - Конвертация
  - Превращение в классический класс
  - Прекращение в современный класс
- Плюшки ES6
  - геттер и сеттер
  - Статические методы
  - Цепной стиль
- Наследование
  - __proto\__.__proto\__
  - super
- Термины
  - Интерфейсы
  - Публичный / Защищенный / Приветный
    - Symbol, WeakMap / костыли
- Немного UML
  - Отношения
  - Готовые шаблоны
  - Редактор
- Несколько паттернов
  - П: Singleton
  - П: Builder


### Ссылочная природа объектов
В JavaScript имеются примитивы и объекты.
Примитивы не хранят на себя ссылку, только передаются по значению, но объекты хранят
ссылку и скопировать его в другой объект путем перезаписи в новую переменную не получится.

### Объект
Что такое поля и методы?
Например:
```
let object = {
    a: 'string',
    method() {},
    method2: () => {}
}
```

Поле в объекте - это хранилище. Оно содержит в себе какую-то информацию.
Методы - это ссылки на поля, которые содержат в себе функции. Но почему метод не называют функцией?
Потому что у метода есть привязка к контексту. Контексту объекта.

Какой будет контекст, если в методе мы выведем this и в поле, где
объект -> метод?

```
let object = {
    a: {
        method() {
            console.log(this)
        }
    },
    method() {
        console.log(this)
    },
    arrowFn: () => {
        console.log(this)
    }
}
```

*this* ссылается на объект, с помощью которого до него обратились.
В объекте object мы обратились к полю method, поэтому его this - это object.

Что если "нырнем глубже" и также проделаем то же самое со стрелочной функцией,
у которого нет собственного контекста?

1. Вызывая контекст внутри объекта "a" мы получим сам объект "a", поскольку мы добирались с помощью него
2. У стрелочной функции контекст - это Window

--------
#### Заимствование контекста, метода
```
const nodeList = querySelectorAll('*');
Мы знаем, что у nodeList нет никаких методов массива помимо forEach.
```
В таком случае, как нам действовать, если мы хотим использовать любой другой метод массива?
Первый вариант - это использовать `Array.from(nodeList)`; Но есть и второй очень классный способ - это
вариант, который везде светится в mdn:
```
Array.prototype.filter.call(nodeList, function() {});
Таким образом мы позаимствовали метод, привязали контекст и обозначили обработчик

То же самое:
[].prototype.filter.call(nodeList, function() {});
```

Еще один пример использования:
```
function f() {
    if ([].includes.call(arguments, 5)) {
        console.log('tru-ue');
    }
}

f(1, 3, 6, 5);
```
Будет выведено 'tru-ue'. С учетом ES6 все можно делать короче:

```
function f(...args) {
    if (args.includes(5)) {
        console.log('tru-ue');
    }
}

f(1, 3, 6, 5);
```

---
#### Магия __proto\__

Хорошо, а теперь давайте создадим объект, у которого будет __\proto\__:
```
const object = {
    a: 'string',
    __ptoto__: {
        c: 'вот поле из прото'
    }
}
```

Что будет выведено в консоль:
`console.log(object)`?

будет выведен объект без `__proto__`:
`{a: string}`;

Хорошо, а что если мы обратимся к полю `c` у `object`?
Нам выведется: *"вот поле из прото"*. Это означает, что в прототип конкретно
этого объекта мы указали свойство, которое движок JS будет пытаться найти в случае,
если оно не будет найдено на верхнем уровне.

Если мы в прототипе укажем метод и попробуем вызвать его контекст, то это будет контекст  объекта,
в котором искался прототип.

А теперь давайте его определим двум объектам следующим образом:
```
const __ptoto__ = {
    c: 'c proto string'
}

const a = {
    a: 'a',
    __proto__
}

const b = {
    b: 'b',
    __proto__
}
```

Как мы уже говорили ранее, мы храним ссылку на объект, поэтому в __proto\__ будет
у каждого  
`c: 'c proto string'`; Хорошо, а что если перезаписать у объекта `a` свойство
`c` и посмотреть, что с ним стало у объекта `b`?

```
a.c = 'a proto changed';
console.log(a.c);
console.log(b.c);

--- результат:
'a proto changed';
'c proto string'
```

Почему так произошло? Потому что мы записали в свойство объекта `a` поле `с`.
А прототип мы не изменяли. Это говорит о том, что `прототипы только на чтение`

А что такое prototype? Это объект, который описывает общие методы и свойства.

```
const b = {
    b: 'b',
    __proto__: prototype
}
```

---
### Фабрика объектов
- Фабрика объектов
    - Присвоение методов
    - Доступ методов через __proto\__
        - Конвертация
    - Превращение в классический класс
    - Прекращение в современный класс
```
const PersonPrototype = {
    sayHello() {
        console.log(`Всем привет от ${this.name} ${this.family}`);
    }
}
function Person(name, family) {
    return {
        name,
        family,
        __proto__: PersonPrototype
    }
}

const person1 = Person('Тико', 'Мико');
```
Мы с вами наблюдаем `класс` с позиции JavaScript. Но раньше это все немного иначе выглядело. Как?
Давайте посмотрим:

```
function Pesron(name, family) {
    this.name = name;
    this.family = family;
}

Person.prototype.sayHello = function() {
    console.log(`Всем привет от ${this.name} ${this.family}`);
}
```
Поговорим в терминах:
**Функции конструкторы**
Их отличает от других функций следующее:
1. Их названия начинаются с заглавной
2. Вызываются с использованием оператора `new`

Почему важно использование оператора `new`? У этого есть 3 причины:
1. Создается новый пустой объект и к нему привязывается this
2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства 
3. возвращается this

```
funciton User(name, age) {
    // неявно this = {};

    // преобразования this
    this.name = name;
    this.age = age;
    
    // неявно return this
}
```
таким образом
`let user = new User('ttt', 26)` делает то же, что и
```
let user = {
    name: 'ttt',
    age: 26
}
```

#### Превращение в современный класс
Фактически, сейчас по сравнению с тем, что мы только что рассмотрели, используется синтаксический сахар.

```
class Pesron {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    sayHello() {}
}
```

---
- Плюшки ES6
    - геттер и сеттер
    - Статические методы
    - Цепной стиль

Держим в голове, что геттеры, сеттеры, цепной стиль - это все было еще в ES5, но у 6 версии
есть синтаксический сахар, который мы можем использовать.

```
class Pesron {
    constructor(name, family) {
        this.name = name;
        this.family = family;
    }

    getFullName() {
        return `${this.name} ${this.family}`;
    }
    
    get fullName() {
        return `${this.name} ${this.family}`;
    }
    
    set fullName(value) {
        const [name, family] = value.split(' ');
        this.name = name;
        this.family = family;
    }
    
    // статический метод
    static create(...args) {
        return new Person(...args);
    }
}
```

Что если мы хотим получить свойство?
Мы можем использовать функцию getFullName. Да, работает. Но для таких целей лучше использовать так
называемый геттер.
```
    const user = new Person(...)
    console.log(user.fullName) // обращаемся, как к свойству
    
    если хотим изменить это поле, то можем использовать одноименный сеттер:
    ser.fullname = '...'
```

Теперь поговорим по поводу `static`.
Этот static позволяет нам обращаться к заданному полю непосредственно через класс, а не его экземпляр.
Статические св-ва и методы наследуются.

Теперь с подобной реализацией статического метода мы можем использовать следующую возможность создания
экземпляра класса:

```
const user = Pesron.create(...); // и все также будет работать
```

Именно это дает нам возможность разрабатывать с применением цепного стиля. Давайте
в классе Counter в каждом методе возвращать this:

```
class Counter {
    constructor() {
        this.counter = 0;
    }
    
    static create(...args) {
        return new Counter(...args);
    }
    
    show() {
        console.log(this.counter);
    }
    
    add(num = 1) {
        this.counter += num;
        return this;
    }
    
    subtracting() {
        --this.counter;    
        return this;
    }
}
```
Теперь мы можем что-то такое:

```
Counter
    .create()
    .show()
    .add()
    .add(3)
    .show()
    .subtracting()
```

---
- Наследование
    - __proto\__.__proto\__
    - super

### __proto\__

```
class Point {
    constructor(x, y) {
        this.y = y;
        this.x = x;
    }
}

class Dot extend Point {} // *
На текущий момент классы Dot и Point ничем друг от друга не отличаются.
А само слово extend делает следующее:
Dot.prototype.__proto__ = Point.prototype;

То есть это эквивалентно:
class Dot extend Point {} 
Dot.prototype.__proto__ = Point.prototype;
```

### Su-uper
Про proto мы уже поговорили, а вот супер еще не рассматривали.
Когда мы наследуемся от класса и создаем функцию конструктор, то мы обязаны вызвать
super. Он задействует функцию конструктор того класса, от которого наследуется.

Мы также можем вызвать super внутри метода, который хотим переопределить

В JavaScript нельзя переопределить конструктор. Его можно унаследовать, либо расширить.

---
- Термины
    - Интерфейсы
    - Публичный / Защищенный / Приветный
        - Symbol, WeakMap / костыли

### Интерфейсы
Слово интерфейсы в спеках JS к 2019 году было зарезервировано как ключевое слово, которое будет
в будущем использоваться. Интерфейсы уже используются в TypeScript. В нем описываются все свойства
и методы класса / объекта.

### Публичный / Защищенный / Приватный
Это все св-ва и методы класса.
Публичные - это те, к которым мы можем обратиться откуда угодно и как угодно.
Защищенные доступны только классу и его потомкам.
Приватные недоступны даже при наследовании.

Можно реализовать приватные св-ва через WeakMap и Symbol, но этом будет далее, когда дойдем
до П: Singleton

---
- Несколько паттернов
    - П: Singleton
    - П: Builder

### Паттерн Singleton
Этот паттерн реализует механику, благодаря которой мы гарантируем, что экземпляр какого-то класса
будет в единственном числе и предоставляет глобальную точку доступа к нему.

Это порождающий тип паттерна.

```
class Signleton {}

const singleton1 = new Signleton();
const singleton2 = new Signleton();

console.log(singleton1 === singleton2); // вернет false
```
Как сделать так, чтобы при вызове new Singleton у нас мы ссылались только на 1 экземпляр?
Попробуем сделать это

```
class Signleton {
    constructor() {
        if (Signleton.instance) {
            return Signleton.instance
        }

        Signleton.instance = this;
    }
}
```

Здесь следует подчеркнуть 2 значимые вещи и объяснить логику. Мы где-то должны хранить информацию о
том, что мы создали экземпляр. Хорошо, почему бы это не сделать в св-ве самого класса?

Когда создается экземпляр, мы помещаем this этого экземпляра в это свойство. Потом, когда мы создаем
новый экземпляр, хочешь того или нет, мы первым делом пойдем в конструктор, где проверим это свойство.
Если оно было записано - существует, то дальше происходит странное: мы возвращаем тот this;

А теперь вопрос: такое возможно? Возвращать в конструкторе что-то свое?
Ответ неоднозначный. Во-первых, мы помним, что в самом конце конструктора неявно возвращается this.

И тогда вопрос сводится к: мы можем его переопределить?
Да, можем, но только в том случае, если мы возвращаем объект. Если мы возвращаем примитив, то он будет
проигнорирован. Таким образом, мы возвращаем this один и тот же каждый раз. Реализация является
примитивной.

Можно ли сломать это как то извне? Да, можно)) Давайте подумаем как.
Фактически, у нас все зависит от св-ва `instance`. Если его не будет, то тогда мы сможем
создать второй экземпляр.

Тогда надо сделать это свойство недоступным.
Ее можно изолировать, если реализовать в другом файле, либо использовать LIFE:

```
;(function() {
let instance = null;
    class Signleton {
        constructor() {
            if (instance) {
                return instance
            }
    
            instance = this;
        }
    }
    
// Дальше надо как то предоставить к этому классу доступ, иначе так он будет недоступным:
window.Singleton = Singleton;
})();
```
