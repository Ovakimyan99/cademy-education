Создание компонента.
Что может быть компонентом?

Первым делом выделим в компоненты шапку и сам пост.
У нас у компонента будет тип. Мы будем передавать внутрь главного
исходного, порождающего компонента тип.

У него будет метод render. Что мы будем делать внутри этого метода?
Сначала создавать дом узел и внутрь записывать весь HTML нашего
метода `getHtmlTemplate`. Откуда берется `getHtmlTemplate`?

Он будет определяться внутри компонентов, например, шапки
и поста.

Какой это паттерн? Factory method.
Потому что то, как будет создан и что будет начинино, мы доверяем уже дочерним
классам.

Дальше создаем Header.
Из чего состоят компоненты? Из модели, view, контроллеров.

Сейчас создадим 2 уровня абстракции.
Вынесем верстку header в html файл.
Теперь надо возвращать логику, которая будет возвращать этот
html.

По сути это должен быть класс, который наследуется от основного Component.
Таким образом, мы будем

И в getHtmlTemplate мы можем возвращать эту строку html.

А теперь, когда у нас есть отдельная сущность Header, нам надо
ее как-то связать с основным application. Как это сделать?
Как вставить этот компонент в основную апликацию и также подгрузить его
в дом?

Благо я сначала сам сделал, а потом уже решил посмотреть.
Делается это так. Мы же создали компонент с хедером?
Создали. Создали у него метод с определением шаблона?
Создали. Тогда давайте в аппликейшон передадим все нужные нам
компоненты и внутри определим логику создания.

Мы массивом передадим все компоненты и внутри в методе рендер
в DocumentFragment все зарандерим, а потом отдадим DocFragment

А теперь, как это делает Алексей. Он передает в router эти компоненты
массивом. Я передавал в аппликейшон, а он в роутер.
Почему?

Наверное, потому что нам надо как то определять шаблон в зависимости от
урла.

Правда, если на то пошло, мы мошли внутри роутера определять
аппликешон.

Дальше Алексей хочет в методе update находить действующий
url среди зарегестрированных. Сохранять его в route.
И также он создает переменную page и в аппликации уже
в update он
1. Вызывает этот метод update у роутера
2. Очищает исходный root (SPA все-таки)
3. Добавляет в рут эту страницу по роутеру

Если бы я пошел своим путем, то роутер генерировал бы несколько
аппликацией получается. И несколько DOM. А здесь
он связывает с роутером аппликацию.

Дальше он там же, где мы и определяем наш route (в update Router)
он хочет в page записывать новый компонент Page.

А, и по сути нам в этот класс Page надо передавать контейнер
роута. То есть все компоненты, которые мы хотим генерить на
странице.

Что мы хотим от этого класса?
Чтобы он генерировал внутри себя / группировал все переданные
компоненты и возвращал их в поле fragment.

Кстати, в чем различие между createDocumentFragment и
new DocumentFragment()?

---
Хорошо. А что если нам надо создать компонент, который должен внутрь
себя принимать другие компоненты?

Что делать тогда?

Предполагаю, что регулярки пойдут в ход. Мы будем отображать внутри
состояние, куда должны будем передавать дом ноду.
(35 минут с конца)

Пока создадим компонент поста. Поскольку его мы и будем вставлять.

Мы формируем в index.js наш контент, верно?
Тогда почему бы там и не сформировать нашу верстку.
Возьмем инстанс контейнера и добавим в него через метод другой инстанс.
Например, Container.add(new Post).

Внутри мы получаем экземпляр, а это означает, что есть возможность изымать
все данные из него

Сам класс Container получается специфичный. Нам не нужно иметь возможность в каждый
компонент прокидывать другие. Поэтому именно в нем реализуем логику храния и добавления
других компонентов.

В методе add прям сразу не обязательно добавлять в root все на свете, что передали.
Это лишние телодвижения, которые мы можем делать только при необходимости, а именно
render

Теперь же мы можем поработать с методом render компонента Container.
Если мы его переопределим, то у нас он не будет выполняться, тк в цепочке наследования
наш метод встретиться раньше.

Но по сути мы хотим добавить промежуточную логику. Промежуточную логику в
классе контейнер. В Component у нас просто возвращается тот html, который
мы возвращаем из файла. Повторять те же действия заново не ок.

Поэтому мы можем обратиться к super.render(). Так мы достанем метод render из
цепочки прототипов и вызовем его.

Хорошо, супер. Мы теперь можем добавлять посты на страницу!
А как мы .. Как добавить информацию о посте?

Во-первых, надо в определенной структуре данных определить данные.
Для поста они будут такими:

```
{
    user: {
        name: '',
        lastName: '',
        img: '',
    },
    
    content: {
        description: '',
        tags: [],
    },
    
    comments: []
}
```
где у каждого комментария будет следующая структура:
```
{
    user: {
        name: '',
        lastName: '',
        img: '',
    },

    content: '',
}
```
А тэги - это набор строк.

Мы передаем эти данные в пост.
И наша задача сделать эти данные в посте иммутабельными. Как это сделать?
Можно конечно зафризить, копировать, но мы можем просто внутри создать
те же структуры и копировать в них данные, доходя до примитив, чтобы не
копировать ссылку.

И дальше нам надо поработать над выводом. Просто над выводом.
Мы можем создать в template.html какое-нибудь уникальное выражение, которое
впоследствии будем заменять с помощью регулярных выражений.

---
Замечательные домашние задания.

1. Создать компоненты CommentsPlace и Comment и вставить эти компоненты
в Post

И тут уже можно применить какие-нибудь паттерны. Например, фасад. Хотя вряд ли это
фасад. Разберемся.

Все было реализовано так:
На этапе получение html, я в темплейты записывал `{%[name]%}` - и поскольку я получал
строку, то с помощью метода replace и регулярок затирал это на тот html, который мне
нужен.

2. Разнообразить исходные данные файла `fakedata.json`

Готово, добавил котиков

3. Создать компонент, унаследованный от Post - PostCarousel с возможностью
вставлять карусель вместо обычной картинки. +
4. Переработать класс Page так, чтобы можно было создать страницы в отдельном
каталоге `pages` и добавлять их непосредственно в роутер
5. Наладить работу роутера так, чтобы он обрабатывал любую страницу,
на которой находится пользователь и выводил соответствующую страницу.

